==State==
1. Создание: внутри компонента создается объект state и наполняется данными.
Внутри метода render эти данные выводятся
2. Изменение state-а: использовать метод setState в который передать объект с полями которые нужно изменить
и новыми значениями
3. Передача параметров в функции из родительского компонента в дочерний:
Способ 1 (рекомендуемый): в качестве параметра атрибута передать функцию, которую нужно забайндить как this
(первый параметр метода bind) и передать внутрь нужное значение (второй параметр метода bind)
Способ 2: в качестве параметра атрибута передать стрелочную функцию в которой вызвать необходимый метод с нужными
значениями

==Жизненные циклы==
https://ru.reactjs.org/docs/react-component.html#the-component-lifecycle

Большинство жизненных циклов доступны для компонентов, которые наследуются от класс React.Component.
ВАЖНО! Не нужно каждый компонент создавать как экземпляр React.Component - для их обработки требуется больше ресурсов.
Иерархия React-приложения сводится к наличии 1 главного компонента, который наследуется от класса React.Component, а остальные
компоненты должны быть функциональными.

</ Монтирование:
    - constructor() - нативных метод ES6
    - componentWillMount() - deprecated
    - static getDerivedStateFromProps(props, state) - используется для изменения state. Должен возвращять новый state
    - render() - рендерит компонент
    - componentDidMount() - сообщает о том, что компонент был смонтирован. Можно выполнять действия, которые требуют наличия
    Dom-узлов. Хорошее место для создания сетевых запросов

</ Обновление:
    - static getDerivedStateFromProps() - используется для изменения state. Должен возвращять новый state
    - shouldComponentUpdate(nextProps, nextState, nextContext) - В данном методе можно оптимизировать приложение
    Должен возвращать true или false. true - компонент должен быть перерисован, false - компонент не нужно перерисовывать
    - render() - рендерит компонент. Не вызывается, если shouldComponentUpdate() вернул false
    - getSnapshotBeforeUpdate(prevProps, prevState) - вызывается перед этапом "фиксирования". Позволяет получить информацию из
    DOM перед возможным изменением
    - componentDidUpdate(prevProps, prevState, snapshot)
</Размонтирование:
    - componentWillUnmount() - удаление компонента из DOM дерева. Используется для очистки памяти (обнуление таймеров, удаление
    подписки)
</Обработка ошибок:
    - static getDerivedStateFromError(error) - вызывается после возникновения ошибки. Получает ошибку в качестве параметра и возвращает
    значение для обновления состояния
    - componentDidCatch(error, errorInfo) - вызывается после возникновения ошибки в компоненте.
    error - ошибка, info - объект с ключом componentStack, содержащий информацию о компоненте, в котором произошла ошибка


==События==
https://reactjs.org/docs/events.html


==Условия==
Существует 2 способа вывода контента по условию:
1. Использовании тернарного оператора внутри return() (блочные конструкции, такие как if, for и т.д.
запрещены в JSX), который будет при истине показывать нужный контент, а при ложном возвращать null.
2. Создание дополнительной переменной внутри render(), но вне return(). Переменной присваивается null
или нужный контент. Сама же переменная передаётся с помощью интерполяции ({переменная}) внутри JSX.


==Списки==
1. Для вывода списков используют нативный метод map на каждой итерации которого возвращается JSX компонент
с соответствующими параметрами
2. React рекомендует использовать ключевое слово key внутри компонента во время итерации. Ему нужно присвоить
уникальное для каждого элемента списка значение. Это позволит в случае модификации одного из компонентов
изменять только нужный компонент. Не рекомендуется использовать индекс элемента (второй параметр метода map)
в качестве значения key, так как это может привести к проблемам производительности и ошибкам при изменении порядка
выводимых элементов списка. Лучше в state указать id для каждого элемента
3. Диначимеские списки: суть функционала состоит в изменении state-а. Например, из компонента, который нужно изменить,
вызывается функция, которая в родительском компоненте вызывает изменение state-a с помощью метода setState().


==Динамические классы==
Динамические классы добавляются с помощью условий основаных на state. Далее формируется массив, который передаётся в атрибут
className в качестве строки