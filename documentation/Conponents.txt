==State==
1. Создание: внутри компонента создается объект state и наполняется данными.
Внутри метода render эти данные выводятся
2. Изменение state-а: использовать метод setState в который передать объект с полями которые нужно изменить
и новыми значениями
3. Передача параметров в функции из родительского компонента в дочерний:
Способ 1 (рекомендуемый): в качестве параметра атрибута передать функцию, которую нужно забайндить как this
(первый параметр метода bind) и передать внутрь нужное значение (второй параметр метода bind)
Способ 2: в качестве параметра атрибута передать стрелочную функцию в которой вызвать необходимый метод с нужными
значениями
4. Метод setState - ассинхронный. Возможный случай, когда во время выполнения this.setState() еще не было получено конечное состояние
компонента. Чтобы избежать таких ситуаций, в метод передаётся callback функция с параметром prevState и возвращается состояние, основанное
на этом параметре:
    this.setState((prevState) => {
        return {
            counter: prevState.counter + 1
        }
    })

==Жизненные циклы==
https://ru.reactjs.org/docs/react-component.html#the-component-lifecycle

Большинство жизненных циклов доступны для компонентов, которые наследуются от класс React.Component.
ВАЖНО! Не нужно каждый компонент создавать как экземпляр React.Component - для их обработки требуется больше ресурсов.
Иерархия React-приложения сводится к наличии 1 главного компонента, который наследуется от класса React.Component, а остальные
компоненты должны быть функциональными.

</ Монтирование:
    - constructor() - нативных метод ES6
    - componentWillMount() - deprecated
    - static getDerivedStateFromProps(props, state) - используется для изменения state. Должен возвращять новый state
    - render() - рендерит компонент
    - componentDidMount() - сообщает о том, что компонент был смонтирован. Можно выполнять действия, которые требуют наличия
    Dom-узлов. Хорошее место для создания сетевых запросов

</ Обновление:
    - static getDerivedStateFromProps() - используется для изменения state. Должен возвращять новый state
    - shouldComponentUpdate(nextProps, nextState, nextContext) - В данном методе можно оптимизировать приложение
    Должен возвращать true или false. true - компонент должен быть перерисован, false - компонент не нужно перерисовывать
    - render() - рендерит компонент. Не вызывается, если shouldComponentUpdate() вернул false
    - getSnapshotBeforeUpdate(prevProps, prevState) - вызывается перед этапом "фиксирования". Позволяет получить информацию из
    DOM перед возможным изменением
    - componentDidUpdate(prevProps, prevState, snapshot)
</Размонтирование:
    - componentWillUnmount() - удаление компонента из DOM дерева. Используется для очистки памяти (обнуление таймеров, удаление
    подписки)
</Обработка ошибок:
    - static getDerivedStateFromError(error) - вызывается после возникновения ошибки. Получает ошибку в качестве параметра и возвращает
    значение для обновления состояния
    - componentDidCatch(error, errorInfo) - вызывается после возникновения ошибки в компоненте.
    error - ошибка, info - объект с ключом componentStack, содержащий информацию о компоненте, в котором произошла ошибка


==Error Boundary==
High order component
Способ отлавливать ошибки в компонентах. В данном компоненте создаём локальное состояние и реализовать метод componentDidCatch(error, info),
который при возникновении ошибки будет возвращать информацию о компоненте внутри которого она произошла и записывать с состояние.
В методе render() обрабатываем состояние и создаём структуру, которая будет отображаться на месте "сломаного" компонента.
Компонент, ошибки которого необходимо обрабатывать, нужно обернуть в <ErrorBoundary>.


==События==
https://reactjs.org/docs/events.html

==Условия==
Существует 2 способа вывода контента по условию:
1. Использовании тернарного оператора внутри return() (блочные конструкции, такие как if, for и т.д.
запрещены в JSX), который будет при истине показывать нужный контент, а при ложном возвращать null.
2. Создание дополнительной переменной внутри render(), но вне return(). Переменной присваивается null
или нужный контент. Сама же переменная передаётся с помощью интерполяции ({переменная}) внутри JSX.


==Списки==
1. Для вывода списков используют нативный метод map на каждой итерации которого возвращается JSX компонент
с соответствующими параметрами
2. React рекомендует использовать ключевое слово key внутри компонента во время итерации. Ему нужно присвоить
уникальное для каждого элемента списка значение. Это позволит в случае модификации одного из компонентов
изменять только нужный компонент. Не рекомендуется использовать индекс элемента (второй параметр метода map)
в качестве значения key, так как это может привести к проблемам производительности и ошибкам при изменении порядка
выводимых элементов списка. Лучше в state указать id для каждого элемента
3. Диначимеские списки: суть функционала состоит в изменении state-а. Например, из компонента, который нужно изменить,
вызывается функция, которая в родительском компоненте вызывает изменение state-a с помощью метода setState().


==Динамические классы==
Динамические классы добавляются с помощью условий основаных на state. Далее формируется массив, который передаётся в атрибут
className в качестве строки


==Фрагменты==
Есть способы возвращать в компоненте несколько тегов без 1 общего родителя (на одном уровне)
1. В методе render() возвращать массив тегов. Важно!!! при таком подходе каждому элементу необходимо присвоить уникальный ключ:
    render() {
        return [
            <div key={'1'}>Element #1</div>,
            <p key={'2'}>Element #2</p>
        ]
    }

2. Использовать React.Fragment: вместо корневого элемента в методе render() обернуть код в <React.Fragment></React.Fragment>:
    render() {
        return (
            <React.Fragment>
                <div>Element #1</div>,
                <p>Element #2</p>
            </React.Fragment>
        )
    }
    Существует короткий синтаксис:
        render() {
            return (
                <>
                    <div>Element #1</div>,
                    <p>Element #2</p>
                </>
            )
        }

3. Создать собственный high order component: создаём компонент, который возвращает props.children. Далее в другом компонент в методе
render() возвращаем код обвёрнутый в созранный компонент:
    HOC:
        const Auxiliary = (props) => {
          return props.children;
        }
        export default Auxiliary;
    Component:
          render() {
                return (
                  <Auxiliary>
                        <div>Element #1</div>,
                        <p>Element #2</p>
                  </Auxiliary>
                )
            }


==Компоненты высшего порядка (HOC)==
Способы создания HOC:
1. Создать обычный React компонент, который возвращал бы props.children
2. Создать функцию, которая принимает компонент. Эта функция принимает в качестве параметра компонент и возвращает JSX код с
изменённым компонентов
    const withClass = (Component, className) => {
      return props => {
        return (
          <div className={className}>
            <Component {...props} />
          </div>
        )
      }
    }


==Валидация входящих параметров==
Prop Types:
npm install --save prop-types

https://ru.reactjs.org/docs/typechecking-with-proptypes.html#gatsby-focus-wrapper

==Референции==
С помощью референций можно получить доступ к какому-то определённому компоненту
Для создания:
1. Передать уникальный index в качестве параметра для нужного компонента
2. В компоненте объявить конструктор и создать в нём переменную, которой присвоить значение React.createRef()
    constructor(props) {
        super(props);
        const refer = React.createRef();
    }
3. Внутри компонента создать атрибут ref которому присвоить значение this.refer
4. Элемент передаётся в свойстве current
    this.refer.current.focus();

==Context API==
Позволяет передавать передавать состояния через компоненты
1. В родителе экспортируем константу
    export const ClickedContext = React.createContext(false);
2. В родителе оборачиваем дочерний компонент, через который должно идти состояние в
    <ClickedContext.Provider value={this.state.clicked}></NameContext.Provider>
3. В компоненте, который должен принять состояние импортиурем константу
    import {NameContext} from <path>;
4. В компоненте, который должен принять состояние добавляем элемент константы с необходимой структурой
    <ClickedContext.Consumer>
        {clicked => clicked ? <p>Clicked</p> : null}
    </ClickedContext.Consumer>